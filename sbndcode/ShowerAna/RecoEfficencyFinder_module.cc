////////////////////////////////////////////////////////////////////////
// Class:       RecoEfficencyFinder
// Module Type: analyzer
// File:        RecoEfficencyFinder_module.cc
//
// Generated at Thu Sep 19 03:45:10 2019 by Dominic Barker using artmod
// from cetpkgsupport v1_14_01.
////////////////////////////////////////////////////////////////////////

//Framework Includes
#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"
#include "canvas/Persistency/Common/FindManyP.h"
//LArSoft Includes 
#include "larcore/Geometry/Geometry.h"
#include "nusimdata/SimulationBase/MCTruth.h"
#include "larsim/MCCheater/BackTrackerService.h"
#include "larsim/MCCheater/ParticleInventoryService.h"
#include "lardataobj/RecoBase/Track.h"
#include "lardataobj/RecoBase/Hit.h"
#include "lardataobj/RecoBase/Shower.h"
#include "lardataobj/RecoBase/PFParticle.h"
#include "lardataobj/RecoBase/Vertex.h"
#include "larcoreobj/SimpleTypesAndConstants/geo_types.h"
#include "larreco/RecoAlg/MCRecoUtils/RecoUtils.h"
#include "larreco/RecoAlg/MCRecoUtils/ShowerUtils.h"
#include "larcorealg/Geometry/BoxBoundedGeo.h"
#include "lardataobj/AnalysisBase/Calorimetry.h"
#include "lardataobj/AnalysisBase/ParticleID.h"
#include "larcoreobj/SummaryData/POTSummary.h"  
#include "nusimdata/SimulationBase/MCFlux.h"
#include "lardata/DetectorInfoServices/DetectorPropertiesService.h"

//C++ Includes
#include <vector>
#include <iostream>

//Root Includes
#include "TSystem.h"
#include "TGraph.h"
#include "TGraphErrors.h"
#include "TF1.h"
#include "TFile.h"

namespace ana {
  class RecoEfficencyFinder;
}

class ana::RecoEfficencyFinder : public art::EDAnalyzer {
public:
  explicit RecoEfficencyFinder(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  RecoEfficencyFinder(RecoEfficencyFinder const &) = delete;
  RecoEfficencyFinder(RecoEfficencyFinder &&) = delete;
  RecoEfficencyFinder & operator = (RecoEfficencyFinder const &) = delete;
  RecoEfficencyFinder & operator = (RecoEfficencyFinder &&) = delete;

  // Required functions.
  void analyze(art::Event const & e) override;
  void beginJob() override;
  void beginSubRun(const art::SubRun& sr) override;
  void endJob() override;
  bool containedInAV(const TVector3 &v);
  bool containedInFV(const TVector3 &v);

  bool isFromNuVertex(const art::Ptr<simb::MCTruth>& mc, const simb::MCParticle* &particle, float distance=5.) const;
  bool isFromNuVertex(const art::Ptr<simb::MCTruth>& mc, TVector3& position, float distance=5.) const;
  bool isShowerContainedish(const std::vector<int>& shower, std::map<int,float>& Track_Energy_map,std::map<int, const simb::MCParticle*>& trueParticles);
  bool isPrimaryHadron(const int& track, art::Ptr<simb::MCTruth>& mc_truth, std::map<int,const simb::MCParticle*>& trueParticles,int neutrino_iter,std::map<int,float>& Track_Energy_map);
  void OrderShowerHits(std::vector<art::Ptr<recob::SpacePoint> >& sps, const TVector3& ShowerStartPosition, const TVector3& ShowerDirection);
  void OrderPerpendiuclarShowerHits(std::vector<art::Ptr<recob::SpacePoint> >& sps, const TVector3& ShowerStartPosition, const TVector3& ShowerDirection);

  int SpacePointPlane(art::Ptr<recob::SpacePoint> const& sp,
		      art::FindManyP<recob::Hit> const& fmh) const ;
    
  double  TotalCharge(const std::vector<art::Ptr<recob::SpacePoint> >&sps, art::FindManyP<recob::Hit> const& fmh);

  double SpacePointCharge(art::Ptr<recob::SpacePoint> const& sp,
			  art::FindManyP<recob::Hit> const& fmh) const;

  double SpacePointTime(art::Ptr<recob::SpacePoint> const& sp,
			art::FindManyP<recob::Hit> const& fmh) const;
    

  double SpacePointProjection(const art::Ptr<recob::SpacePoint>&sp,
			      TVector3 const& vertex, 
			      TVector3 const& direction) const; 

  double ShowerPerpendicularDensityGradient(std::vector<art::Ptr<recob::SpacePoint> >& sps, const TVector3& ShowerStartPosition, const TVector3& ShowerDirection, double ShowerPerpendicularLength, art::FindManyP<recob::Hit> const& fmh);

  double ShowerDensityGradient(std::vector<art::Ptr<recob::SpacePoint> >& sps, const TVector3& ShowerStartPosition, const TVector3& ShowerDirection, double ShowerLength, art::FindManyP<recob::Hit> const& fmh);

  double ShowerDensityGradient(std::vector<art::Ptr<recob::SpacePoint> >& sps, const TVector3& ShowerStartPosition, const TVector3& ShowerDirection, double ShowerLength, double& OpenAngle, art::FindManyP<recob::Hit> const& fmh, double ShowerEnergy, double& pw);


  TVector3 SpacePointPosition(art::Ptr<recob::SpacePoint> const& sp) const;

  double SignalOscillationWeight(int& initpdg, int& finpdg, float& lOverE) const;
  
  double TotalEnergy(const std::vector<art::Ptr<recob::SpacePoint> >&sps, art::FindManyP<recob::Hit> const& fmh);

private:

  //Module Labels
  art::InputTag fShowerModuleLabel;
  art::InputTag fPFParticleLabel;
  art::InputTag fGenieGenModuleLabel;
  art::InputTag fCalorimetryModuleLabel;
  art::InputTag fTrackModuleLabel;
  art::InputTag fLArGeantModuleLabel;
  art::InputTag fParticleIDModuleLabel;
  art::InputTag fHitsModuleLabel;

  //Fcl parameters 
  float fMinRecoEnergyCut;
  float fNSegments;
  std::vector<geo::BoxBoundedGeo> fActiveVolume; //!< List of active volumes
  std::vector<geo::BoxBoundedGeo> fFiducalVolume;
  double fdmsq;
  double fsinsq2thmumu;
  double fsinsq2thmue;
  bool fRemoveStartFin;

  double fOscDimensFactor = 1.26693281; // Dimensional factor (GeV/eV^2/km) appearing in netrino oscillation formula;

  std::vector<double> fConversion = {0.00155644,0.00173915,0.00153631};
  

  //services
  detinfo::DetectorProperties const* fDetProp;
  art::ServiceHandle<cheat::ParticleInventoryService> particleInventory;
  art::ServiceHandle<art::TFileService> tfs;

  //Branches
  std::vector<float> number_of_showers_per_neutrino;
  std::vector<float> vertex_recoKE_branch;
  std::vector<float> vertex_trueKE_branch;
  std::vector<float> vertex_reco_branch;
  std::vector<float> nu_reco_energy_branch;
  std::vector<float> nu_truth_energy_branch;
  std::vector<float> nu_interaction_type_branch;
  std::vector<float> nu_mode_branch;
  std::vector<float> nu_E_branch;
  std::vector<float> nu_leptonE_branch;
  std::vector<float> nu_E_numtrue_branch;
  std::vector<float> nu_distance_branch;
  std::vector<float> nu_osc_prob_branch;
  std::vector<float> nu_X_branch;
  std::vector<float> nu_W_branch;
  std::vector<float> nu_Y_branch;
  std::vector<float> nu_QSqr_branch;
  std::vector<float> nu_Pt_branch;
  std::vector<float> nu_Theta_branch;
  std::vector<float> nu_truepdg_branch;
  std::vector<float> nu_cc_branch;
  std::vector<float> nu_nuc_branch;

  std::vector<float> nu_pdg_branch;
  std::vector<float> in_FV_branch;
  std::vector<std::vector<float> > truepionE_branch;
  std::vector<std::vector<float> > trueprotonE_branch;
  std::vector<std::vector<float> > truekaonE_branch;
  std::vector<std::vector<float> > truetrackE_branch;
  std::vector<std::vector<float> > shower_energy_branch;
  std::vector<std::vector<float> > truth_pid_branch;
  std::vector<std::vector<float> > true_energy_branch;
  std::vector<std::vector<float> > shower_coversion_gap_branch;
  std::vector<std::vector<float> > shower_residual_dist_branch;
  std::vector<std::vector<float> > shower_len_branch;
  std::vector<std::vector<float> > shower_length_branch;
  std::vector<std::vector<float> > shower_density_branch;
  std::vector<std::vector<float> > shower_length_perp_branch;
  std::vector<std::vector<float> > shower_density_perp_branch;
  std::vector<std::vector<float> > shower_density_3D_branch;
  std::vector<std::vector<float> > shower_density_grad_perp_branch;
  std::vector<std::vector<float> > shower_density_grad_branch;
  std::vector<std::vector<float> > shower_density_ratio_branch;
  std::vector<std::vector<float> > shower_density_grad_ratio_branch;
  std::vector<std::vector<float> > shower_density_grad_perp_sq_branch;
  std::vector<std::vector<float> > shower_density_grad_sq_branch;
  std::vector<std::vector<float> > shower_density_grad_ratio_sq_branch;
  std::vector<std::vector<float> > shower_density_grad_new_branch;
  std::vector<std::vector<float> > shower_open_angle_branch;
  std::vector<std::vector<float> > shower_density_pw_new_branch;
  std::vector<std::vector<float> > shower_density_pwgrad_new_branch;
  std::vector<std::vector<float> > shower_tracklength_branch;
  std::vector<std::vector<float> > shower_trackwidth_branch;

  std::vector<std::vector<float> > shower_dEdx_branch;
  std::vector<std::vector<float> > track_lengths_branch;

  std::vector<std::vector<float> > track_E_branch;
  std::vector<std::vector<float> > track_PIDA_branch;
  std::vector<std::vector<float> > track_trueE_branch;
  std::vector<std::vector<float> > track_pdg_branch; 
  std::vector<std::vector<float> > track_resE_branch;
  std::vector<std::vector<float> > shower_hits_branch;
  
  float trueShower_num_branch;
  float numtrueVtx_branch;

  float POT;

  //TTree
  TTree* Tree;
  TTree* POTTree;

  TGraph* SegmentDensityPerpGraph;
  TGraphErrors* SegmentDensityGraph;
  TGraph* AllThePoints;

  int num_v_recoed;

  std::vector<double> SegmentDensityPerpFinal;
  std::vector<double> SegmentDensityFinal;
  std::vector<double> SegmentDensityFinalN;
  std::vector<double> SegmentDensityPerpFinalN;
  std::vector<double> SegmentDensityFinalSq;
  std::vector<double> LengthToSegmentFinal;
  std::vector<double> LengthToSegmentFinalSq;
  double Nfinal;

  TFile* file = new TFile("test.root","RECREATE");

};


ana::RecoEfficencyFinder::RecoEfficencyFinder(fhicl::ParameterSet const & pset)
  :
  EDAnalyzer(pset),
  fShowerModuleLabel     (pset.get<art::InputTag>("ShowerModuleLabel")),
  fPFParticleLabel       (pset.get<art::InputTag>("PFParticleLabel")),
  fGenieGenModuleLabel   (pset.get<art::InputTag>("GenieGenModuleLabel")),
  fCalorimetryModuleLabel(pset.get<art::InputTag>("CalorimetryModuleLabel")),
  fTrackModuleLabel      (pset.get<art::InputTag>("TrackModuleLabel")),
  fLArGeantModuleLabel   (pset.get<art::InputTag>("LArGeantModuleLabel")),
  fParticleIDModuleLabel (pset.get<art::InputTag>("ParticleIDModuleLabel")),
  fHitsModuleLabel       (pset.get<art::InputTag>("HitsModuleLabel")),
  fMinRecoEnergyCut      (pset.get<float>        ("MinRecoEnergyCut")),
  fNSegments             (pset.get<float>        ("NSegments")),
  fdmsq                  (pset.get<float>        ("dmsq")),
  fsinsq2thmumu          (pset.get<float>        ("sinsq2thmumu")),   
  fsinsq2thmue           (pset.get<float>        ("sinsq2thmue")),
  fRemoveStartFin        (pset.get<bool>("RemoveStartFin")),
  fDetProp(lar::providerFrom<detinfo::DetectorPropertiesService>())
{

  SegmentDensityPerpFinal.resize(fNSegments,0);
  SegmentDensityFinal.resize(fNSegments,0);
  SegmentDensityFinalN.resize(fNSegments,0);
  SegmentDensityPerpFinalN.resize(fNSegments,0);
  SegmentDensityFinalSq.resize(fNSegments,0);
  LengthToSegmentFinal.resize(fNSegments,0);
  LengthToSegmentFinalSq.resize(fNSegments,0);

  // setup active volume bounding boxes
  std::vector<fhicl::ParameterSet> AVs =				\
    pset.get<std::vector<fhicl::ParameterSet> >("ActiveVolume");
  for (auto const& AV : AVs) {
    double xmin = AV.get<double>("xmin");
    double ymin = AV.get<double>("ymin");
    double zmin = AV.get<double>("zmin");
    double xmax = AV.get<double>("xmax");
    double ymax = AV.get<double>("ymax");
    double zmax = AV.get<double>("zmax");
    fActiveVolume.emplace_back(xmin, xmax, ymin, ymax, zmin, zmax);
  }

  std::vector<fhicl::ParameterSet> FVs =				\
    pset.get<std::vector<fhicl::ParameterSet> >("FiducalVolume");
  for (auto const& FV : FVs) {
    double xmin = FV.get<double>("xmin");
    double ymin = FV.get<double>("ymin");
    double zmin = FV.get<double>("zmin");
    double xmax = FV.get<double>("xmax");
    double ymax = FV.get<double>("ymax");
    double zmax = FV.get<double>("zmax");
    fFiducalVolume.emplace_back(xmin, xmax, ymin, ymax, zmin, zmax);
  }



}

void ana::RecoEfficencyFinder::beginSubRun(const art::SubRun& sr)
{
  art::Handle< sumdata::POTSummary > potListHandle;

  if(sr.getByLabel(fGenieGenModuleLabel,potListHandle))
    POT = potListHandle->totpot;
  
  POTTree->Fill();
}



void ana::RecoEfficencyFinder::beginJob() {

  POTTree = tfs->make<TTree>("RecoEffPOTTree", "Tree Holding POT information");
  POTTree->Branch("POT",&POT,32000,0);
      
  Tree = tfs->make<TTree>("RecoEffMetricTree", "Tree Holding all metric information");
  gInterpreter->GenerateDictionary("vector<vector<float> >","vector");

  SegmentDensityPerpGraph = tfs->makeAndRegister<TGraph>("SegmentDensityPerpGraph","SegmentDensityPerpGraph");
  SegmentDensityGraph = tfs->makeAndRegister<TGraphErrors>("SegmentDensityGraph","SegmentDensityGraph");
  AllThePoints  = tfs->makeAndRegister<TGraph>("AllThePoints","AllThePoints");

  //Initalise the branches
  Tree->Branch("number_of_showers_per_neutrino","std::vector<float>", &number_of_showers_per_neutrino, 32000, 0);
  Tree->Branch("shower_energy","std::vector<std::vector<float> >", &shower_energy_branch, 32000, 0);
  Tree->Branch("truth_pid","std::vector<std::vector<float> >", &truth_pid_branch,32000,0);
  Tree->Branch("true_energy","std::vector<std::vector<float> >",&true_energy_branch,32000,0);
  Tree->Branch("trueShower_num",&trueShower_num_branch,32000,0);
  Tree->Branch("numtrueVtx_branch",&numtrueVtx_branch,32000,0);
  Tree->Branch("vertex_recoK","std::vector<float>",&vertex_recoKE_branch,32000,0);
  Tree->Branch("vertex_trueK","std::vector<float>",&vertex_trueKE_branch,32000,0);

  Tree->Branch("true_trackE","std::vector<std::vector<float>>",&truetrackE_branch,32000,0);
  Tree->Branch("true_pionE","std::vector<std::vector<float>>",&truepionE_branch,32000,0);
  Tree->Branch("true_protonE","std::vector<std::vector<float>>",&trueprotonE_branch,32000,0);
  Tree->Branch("true_kaonE","std::vector<std::vector<float>>",&truekaonE_branch,32000,0);

  Tree->Branch("vertex_reco","std::vector<float>",&vertex_reco_branch,32000,0);
  Tree->Branch("shower_coversion_gap","std::vector<std::vector<float>>",&shower_coversion_gap_branch,32000,0);
  Tree->Branch("shower_residual_dist","std::vector<std::vector<float>>",&shower_residual_dist_branch,32000,0);
  Tree->Branch("shower_len","std::vector<std::vector<float>>",&shower_len_branch,32000,0);
  Tree->Branch("shower_length","std::vector<std::vector<float>>",&shower_length_branch,32000,0);
  Tree->Branch("shower_density","std::vector<std::vector<float>>",&shower_density_branch,32000,0);
  Tree->Branch("shower_length_perp","std::vector<std::vector<float>>",&shower_length_perp_branch,32000,0);
  Tree->Branch("shower_density_perp","std::vector<std::vector<float>>",&shower_density_perp_branch,32000,0);
  Tree->Branch("shower_density_3D","std::vector<std::vector<float>>",&shower_density_3D_branch,32000,0);
  Tree->Branch("shower_density_grad_perp","std::vector<std::vector<float>>",&shower_density_grad_perp_branch,32000,0);
  Tree->Branch("shower_density_grad","std::vector<std::vector<float>>",&shower_density_grad_branch,32000,0);
  Tree->Branch("shower_density_ratio","std::vector<std::vector<float>>",&shower_density_ratio_branch,32000,0);
  Tree->Branch("shower_density_grad_ratio","std::vector<std::vector<float>>",&shower_density_grad_ratio_branch,32000,0);
  Tree->Branch("shower_density_grad_ratio_sq","std::vector<std::vector<float>>",&shower_density_grad_ratio_sq_branch,32000,0);
  Tree->Branch("shower_density_grad_perp_sq","std::vector<std::vector<float>>",&shower_density_grad_perp_sq_branch,32000,0);
  Tree->Branch("shower_density_grad_sq","std::vector<std::vector<float>>",&shower_density_grad_sq_branch,32000,0);
  Tree->Branch("shower_density_grad_new","std::vector<std::vector<float>>",&shower_density_grad_new_branch,32000,0);
  Tree->Branch("shower_open_angle","std::vector<std::vector<float>>",&shower_open_angle_branch,32000,0);
  Tree->Branch("shower_density_pw_new","std::vector<std::vector<float>>",&shower_density_pw_new_branch,32000,0);
  Tree->Branch("shower_density_pwgrad_new","std::vector<std::vector<float>>",&shower_density_pwgrad_new_branch,32000,0);
  Tree->Branch("shower_dEdx","std::vector<std::vector<float>>",&shower_dEdx_branch,32000,0);
  Tree->Branch("shower_tracklength", "std::vector<std::vector<float>>", &shower_tracklength_branch,32000,0);   
  Tree->Branch("shower_trackwidth","std::vector<std::vector<float>>", &shower_trackwidth_branch,32000,0);   
  Tree->Branch("shower_hits","std::vector<std::vector<float>>", &shower_hits_branch,32000,0);   



  Tree->Branch("track_lengths","std::vector<std::vector<float>>",&track_lengths_branch,32000,0);
  Tree->Branch("track_E","std::vector<std::vector<float>>",&track_E_branch,32000,0);
  Tree->Branch("track_trueE","std::vector<std::vector<float>>",&track_trueE_branch,32000,0);
  Tree->Branch("track_pdg","std::vector<std::vector<float>>",&track_pdg_branch,32000,0);
  Tree->Branch("track_resE","std::vector<std::vector<float>>",&track_resE_branch,32000,0);
  Tree->Branch("track_PIDA_branch","std::vector<std::vector<float>>",&track_PIDA_branch,32000,0);

  Tree->Branch("nu_reco_energy","std::vector<float>",&nu_reco_energy_branch,32000,0);
  Tree->Branch("nu_truth_energy","std::vector<float>",&nu_truth_energy_branch,32000,0);
  Tree->Branch("nu_interaction_type","std::vector<float>",&nu_interaction_type_branch,32000,0);
  Tree->Branch("nu_mode","std::vector<float>",&nu_mode_branch,32000,0);
  Tree->Branch("nu_E","std::vector<float>",&nu_E_branch,32000,0);
  Tree->Branch("nu_leptonE","std::vector<float>",&nu_leptonE_branch,32000,0);
  Tree->Branch("nu_E_numtrue","std::vector<float>",&nu_E_numtrue_branch,32000,0);
  Tree->Branch("nu_X", "std::vector<float>", &nu_X_branch,32000,0);
  Tree->Branch("nu_W","std::vector<float>", &nu_W_branch,32000,0);
  Tree->Branch("nu_Y","std::vector<float>",&nu_Y_branch,32000,0);
  Tree->Branch("nu_QSqr","std::vector<float>",&nu_QSqr_branch,32000,0);
  Tree->Branch("nu_Pt","std::vector<float>",&nu_Pt_branch,32000,0);
  Tree->Branch("nu_Theta","std::vector<float>",&nu_Theta_branch,32000,0);

  
  Tree->Branch("nu_distance","std::vector<float>",&nu_distance_branch,32000,0);
  Tree->Branch("in_FV","std::vector<float>", &in_FV_branch, 32000,0);
  Tree->Branch("nu_osc_prob","std::vector<float>",&nu_osc_prob_branch,32000,0);
  Tree->Branch("nu_pdg","std::vector<float>",&nu_pdg_branch,32000,0);
  Tree->Branch("nu_truepdg","std::vector<float>",&nu_truepdg_branch,32000,0);
  Tree->Branch("nu_cc","std::vector<float>",&nu_cc_branch,32000,0);
  Tree->Branch("nu_nuc","std::vector<float>",&nu_nuc_branch,32000,0);

  num_v_recoed = 0;

 }

void ana::RecoEfficencyFinder::analyze(art::Event const & evt){

  auto const& mcflux = evt.getValidHandle<std::vector<simb::MCFlux> >(fGenieGenModuleLabel);

  //Get the showers 
  art::Handle<std::vector<recob::Shower> > showerListHandle;
  std::vector<art::Ptr<recob::Shower> > showers;
  if(evt.getByLabel(fShowerModuleLabel,showerListHandle)){
    art::fill_ptr_vector(showers,showerListHandle);
  }

  //Get the pf particles 
  art::Handle<std::vector<recob::PFParticle> > pfpHandle;
  std::vector<art::Ptr<recob::PFParticle> > pfps;
  if(evt.getByLabel(fPFParticleLabel,pfpHandle))
    {art::fill_ptr_vector(pfps,pfpHandle);}

  // * MC truth information
  art::Handle<std::vector<simb::MCTruth> > mctruthListHandle;
  std::vector<art::Ptr<simb::MCTruth> > mclist;
  if (evt.getByLabel(fGenieGenModuleLabel,mctruthListHandle))
    art::fill_ptr_vector(mclist, mctruthListHandle);

  //Get the tracks
  art::Handle<std::vector<recob::Track> > trackListHandle;
  evt.getByLabel(fTrackModuleLabel,trackListHandle);
  if(!trackListHandle.isValid()){
    throw cet::exception("RecoEfficencyFinder") << "Track list not valid";
    return;
  }

  //Getting the Hit Information
  art::Handle<std::vector<recob::Hit> > HitHandle;
  std::vector<art::Ptr<recob::Hit> > hits;
  if(!evt.getByLabel(fHitsModuleLabel,HitHandle)){
    throw cet::exception("RecoEfficencyFinder") << "Hits not valud";
    return;
  }

  //Get the SimChannels so that we can find the IDEs deposited on them.
  art::Handle<std::vector<sim::SimChannel> > simChannelHandle;
  std::vector<art::Ptr<sim::SimChannel> > simchannels;
  if(evt.getByLabel(fLArGeantModuleLabel,simChannelHandle))
  {art::fill_ptr_vector(simchannels, simChannelHandle);}


  //Association between Showers and pfParticle
  art::FindManyP<recob::Shower> fmsh(pfpHandle, evt, fShowerModuleLabel);
  if(!fmsh.isValid()){
    throw cet::exception("RecoEfficencyFinder") << "Shower and PF particle association is somehow not valid. Stopping";
    return;
  }
  
  //Assocations between pfparticle and vertex.
  art::FindManyP<recob::Vertex> fmv(pfpHandle, evt, fPFParticleLabel);
  if(!fmv.isValid()){
    throw cet::exception("RecoEfficencyFinder") << "Vertex and PF particle association is somehow not valid. Stopping";
    return;
  }

  //Association between Showers and 2d Hits
  art::FindManyP<recob::Hit> fmh(showerListHandle, evt, fShowerModuleLabel);
  if(!fmh.isValid()){
    throw cet::exception("RecoEfficencyFinder") << "Hit-Recob::Shower association is somehow not valid. Stopping";
    return;
  }

  //Association between Showers and 2d Hits
  art::FindManyP<recob::SpacePoint> fmsp(showerListHandle, evt, fShowerModuleLabel);
  if(!fmsp.isValid()){
    throw cet::exception("RecoEfficencyFinder") << "Spacepoint-Recob::Shower association is somehow not valid. Stopping";
    return;
  }

  //Get the spacepoints handle and the hit assoication
  art::Handle<std::vector<recob::SpacePoint> > spHandle;
  if (!evt.getByLabel(fPFParticleLabel, spHandle)){
    throw cet::exception("RecoEfficencyFinder") << "Could not configure the spacepoint handle. Something is configured incorrectly. Stopping";
    return;
  }
  art::FindManyP<recob::Hit> fmsph(spHandle, evt, fPFParticleLabel);
  if(!fmsph.isValid()){
    throw cet::exception("RecoEfficencyFinder") << "Spacepoint to hit association not valid. Stopping.";
    return;
  }
  

  //Get the shower track stubs and hits
  art::FindManyP<recob::Track> fmst(showerListHandle, evt, fShowerModuleLabel);
  if(!fmst.isValid()){
    throw cet::exception("RecoEfficencyFinder") << "Track and Shower association is somehow not valid. Stopping";
    return;
  }
  //and the hits
  art::Handle<std::vector<recob::Track> > showertrackHandle;
  std::vector<art::Ptr<recob::Track> > showertrack;
  if(evt.getByLabel(fShowerModuleLabel,showertrackHandle))
    {art::fill_ptr_vector(showertrack,showertrackHandle);}
  art::FindManyP<recob::Hit> fmsth(showertrackHandle, evt, fShowerModuleLabel);
  if(!fmsth.isValid()){
    throw cet::exception("RecoEfficencyFinder") << "Track  and hit association is somehow not valid. Stopping";
    return;
  }

  //Get the spacepoints handle and the hit assoication  
  art::FindManyP<recob::SpacePoint> fmsphsp(HitHandle, evt,fPFParticleLabel);
  if(!fmsphsp.isValid()){
    throw cet::exception("RecoEfficencyFinder") << "this one Spacepoint and hit association not valid. Stopping.";
    return ;
  }


  //Assn between Tracks and pfparticles
  art::FindManyP<recob::Track> fmt(pfpHandle, evt, fTrackModuleLabel);
  if(!fmt.isValid()){
    throw cet::exception("RecoEfficencyFinder") << "Track and PF particle association is somehow not valid. Stopping";
    return;
  }

  //Assn between Tracks and calo
  art::FindManyP<anab::Calorimetry> fmcal(trackListHandle, evt, fCalorimetryModuleLabel);
  if(!fmt.isValid()){
    throw cet::exception("RecoEfficencyFinder") << "Track and PF particle association is somehow not valid. Stopping";
    return;
  }

  //Assn between Tracks and hits
  art::FindManyP<recob::Hit> fmth(trackListHandle, evt, fTrackModuleLabel);
  if(!fmth.isValid()){
    throw cet::exception("RecoEfficencyFinder") << "Track and PF particle association is somehow not valid. Stopping";
    return;
  }


  art::FindManyP<anab::ParticleID> fmpid(trackListHandle, evt, fParticleIDModuleLabel);
  if(!fmth.isValid()){
    throw cet::exception("RecoEfficencyFinder") << "Track and PID association is somehow not valid. Stopping";
    return;
  }
  

  //What energy do we actually reconstruct the shower. 

  //List the particles in the event
  const sim::ParticleList& particles = particleInventory->ParticleList();

  //Make a map of Track id and pdgcode
  std::map<int,int> trueParticleEnergy;
  std::map<int, const simb::MCParticle*> trueParticles;
  for (sim::ParticleList::const_iterator particleIt = particles.begin(); particleIt != particles.end(); ++particleIt){

      const simb::MCParticle *particle = particleIt->second;
      trueParticleEnergy[particle->TrackId()] = 0;
      trueParticles[particle->TrackId()] = particle;

    //    std::cout << "particle id: " << particle->TrackId() << " pdg: " << particle->PdgCode() << " Mother: " << particle->Mother() << " E: " << particle->E() << std::endl;

  }


  //Get the true showers. This is a map of the mother id with the down stream mothers 
  std::map<int,std::vector<int> > trueShowerCandidates = ShowerUtils::GetShowerMothersCandidates(trueParticles);
  std::map<int,float> MCTrack_Energy_map = RecoUtils::TrueEnergyDepositedFromMCTracks(simchannels);

  std::map<int,std::vector<int> > trueShowers;
  //Remove showers candiates  which are not neutrino ones.
  int numVtx=0;
  for(auto const& trueShowerCandidate: trueShowerCandidates){
    
    //Assume anything that comes from the vertex is a shower. 
    for(auto const& mc: mclist){

      //Only deal with neutrinos 
      if(mc->Origin() != simb::kBeamNeutrino){continue;} 

      if(!isFromNuVertex(mc,trueParticles[trueShowerCandidate.first])){continue;}
      
      //Make sure that the shower started is contained
      if(!isShowerContainedish(trueShowerCandidate.second,MCTrack_Energy_map,trueParticles)){continue;}

      //Make sure we are not a silly photon below 10 MeV 
      if(trueParticles[trueShowerCandidate.first]->E()*1000 < 10){continue;}

      trueShowers[trueShowerCandidate.first] = trueShowerCandidate.second;
    }
  }
  trueShowerCandidates.clear();
  
  trueShower_num_branch = trueShowers.size();

  //For the time being Lets not continue without a neutrino vertex in the AV.
  for(auto const& mc: mclist){

    //Only deal with neutrinos 
    if(mc->Origin() != simb::kBeamNeutrino){continue;} 

    //Count the number of vertices that can be reconstructed.
    const TVector3 nuVtx = mc->GetNeutrino().Nu().Trajectory().Position(0).Vect(); 

    if(containedInAV(nuVtx)){
      nu_E_numtrue_branch.push_back(mc->GetNeutrino().Nu().E());
      ++numVtx;
    }
  }

  //  if(numVtx == 0){return;}

  numtrueVtx_branch = numVtx;

  //Loop over fpf and find the neutrinos
  std::vector<art::Ptr<recob::PFParticle> > neutrinos;
  for(auto const& pfp: pfps){
    if(TMath::Abs(pfp->PdgCode()) == 12 || TMath::Abs(pfp->PdgCode()) == 14){
      neutrinos.push_back(pfp);
    }
  }

  //Make the pfp map
  std::map<int, art::Ptr<recob::PFParticle> > pfp_map;
  for(auto const& pfp: pfps){
      pfp_map[pfp->Self()] = pfp;
  }


  int neutrino_iter=0;

  number_of_showers_per_neutrino.resize(neutrinos.size(),-999);
  vertex_recoKE_branch.resize(neutrinos.size(),-999); 
  vertex_trueKE_branch.resize(neutrinos.size(),-999); 
  vertex_reco_branch.resize(neutrinos.size(),-999);
  nu_reco_energy_branch.resize(neutrinos.size(),-999);
  nu_distance_branch.resize(neutrinos.size(),-999);
  nu_pdg_branch.resize(neutrinos.size(),-999);
  nu_truepdg_branch.resize(neutrinos.size(),-999);
  nu_cc_branch.resize(neutrinos.size(),-999);
  nu_osc_prob_branch.resize(neutrinos.size(),-999);
  in_FV_branch.resize(neutrinos.size(),-999);
  
  shower_energy_branch.resize(neutrinos.size());
  truth_pid_branch.resize(neutrinos.size()); 
  true_energy_branch.resize(neutrinos.size()); 
  shower_coversion_gap_branch.resize(neutrinos.size());
  shower_residual_dist_branch.resize(neutrinos.size());
  shower_len_branch.resize(neutrinos.size());
  shower_length_branch.resize(neutrinos.size());
  shower_density_branch.resize(neutrinos.size());
  shower_length_perp_branch.resize(neutrinos.size());
  shower_density_perp_branch.resize(neutrinos.size());
  shower_density_3D_branch.resize(neutrinos.size());
  shower_density_grad_perp_branch.resize(neutrinos.size());
  shower_density_grad_branch.resize(neutrinos.size());
  shower_density_ratio_branch.resize(neutrinos.size());
  shower_density_grad_ratio_branch.resize(neutrinos.size());
  shower_density_grad_perp_sq_branch.resize(neutrinos.size());
  shower_density_grad_sq_branch.resize(neutrinos.size());
  shower_density_grad_ratio_sq_branch.resize(neutrinos.size());
  shower_density_grad_new_branch.resize(neutrinos.size());
  shower_open_angle_branch.resize(neutrinos.size());
  shower_density_pw_new_branch.resize(neutrinos.size());
  shower_density_pwgrad_new_branch.resize(neutrinos.size());
  shower_tracklength_branch.resize(neutrinos.size());   
  shower_trackwidth_branch.resize(neutrinos.size());   
  shower_hits_branch.resize(neutrinos.size());   

  shower_dEdx_branch.resize(neutrinos.size());
  track_lengths_branch.resize(neutrinos.size());   
  nu_truth_energy_branch.resize(neutrinos.size()); 
  nu_interaction_type_branch.resize(neutrinos.size());
  nu_mode_branch.resize(neutrinos.size());
  nu_E_branch.resize(neutrinos.size());
  nu_leptonE_branch.resize(neutrinos.size());
  nu_X_branch.resize(neutrinos.size());
  nu_W_branch.resize(neutrinos.size());
  nu_Y_branch.resize(neutrinos.size());
  nu_QSqr_branch.resize(neutrinos.size());
  nu_Pt_branch.resize(neutrinos.size());
  nu_Theta_branch.resize(neutrinos.size());
  nu_nuc_branch.resize(neutrinos.size());

  track_E_branch.resize(neutrinos.size());
  track_PIDA_branch.resize(neutrinos.size());  
  track_trueE_branch.resize(neutrinos.size());
  track_pdg_branch.resize(neutrinos.size());
  truepionE_branch.resize(neutrinos.size());
  trueprotonE_branch.resize(neutrinos.size());
  truekaonE_branch.resize(neutrinos.size());
  truetrackE_branch.resize(neutrinos.size());
  track_resE_branch.resize(neutrinos.size());


  for(auto const neutrino: neutrinos){

    std::vector<art::Ptr<recob::Shower> > neutrino_showers; 
      
    const std::vector<long unsigned int> daughters = neutrino->Daughters();

    for(auto const& daughter: daughters){
      //      std::cout << "daughter id: " << daughter << " pdgcode: " << pfp_map[daughter]->PdgCode() << std::endl;

      //is the daughter a shower.
      if(pfp_map[daughter]->PdgCode() != 11){continue;}

      //Do we have a corresponding shower particle.
      std::vector<art::Ptr<recob::Shower> > shower = fmsh.at(pfp_map[daughter].key());

      //Did we succeed at characterising the shower particle?
      if(shower.size() == 0){std::cout << "no reco shower" << std::endl; continue;}
      

      //If we have two then our charactisation did a silly.
      if(shower.size() != 1){
  	throw cet::exception("RecoEfficencyFinder") << "we have too many recob showers for pfparticles";
  	return;
     }
     
      //Then we have a shower
      neutrino_showers.push_back(shower[0]);

    }
    //    std::cout << " neutrino_showers.size(): " << neutrino_showers.size() << std::endl;

    //Order the showers with regards to their energy
    std::sort(neutrino_showers.begin(), neutrino_showers.end(),[](const art::Ptr<recob::Shower> & a, const art::Ptr<recob::Shower> & b)
	      { 
		return a->Energy().at(a->best_plane()) > b->Energy().at(b->best_plane()); 
	      });

    //Fill the information about the showers
    for(auto const& shower: neutrino_showers){

      //Check the truth out 
      const int ShowerBest_Plane = shower->best_plane();
      std::pair<int,double> ShowerTrackInfo = ShowerUtils::TrueParticleIDFromTrueChain(trueShowers,fmh.at(shower.key()),ShowerBest_Plane);
      truth_pid_branch.at(neutrino_iter).push_back(ShowerTrackInfo.first);

      float true_energy = 0;
      for(auto const& shower_element: trueShowers[ShowerTrackInfo.first]){
	true_energy += MCTrack_Energy_map[shower_element];
      }

      true_energy_branch.at(neutrino_iter).push_back(true_energy);

      //Lets also fill the dEdx.
      shower_dEdx_branch.at(neutrino_iter).push_back(shower->dEdx().at(ShowerBest_Plane));
      //Apply reconstruction energy cut. 
      const std::vector<double> ShowerEnergyPlanes = shower->Energy(); //MeV
      //      auto const  max_shower_energy = *max_element(std::begin(ShowerEnergyPlanes), std::end(ShowerEnergyPlanes));
      float max_shower_energy = ShowerEnergyPlanes[0];
      std::cout << "max shower e: " << max_shower_energy << std::endl;
      if(ShowerBest_Plane != -999){
	if((int) ShowerEnergyPlanes.size() > ShowerBest_Plane+1){
	  max_shower_energy = ShowerEnergyPlanes[ShowerBest_Plane];
	}
      }

      double ShowerLength  = shower->Length();

      std::cout << "max shower e: " << max_shower_energy << std::endl;

      //      if(max_shower_energy > fMinRecoEnergyCut){
      shower_energy_branch.at(neutrino_iter).push_back(max_shower_energy);
      shower_length_branch.at(neutrino_iter).push_back(ShowerLength);
      shower_density_branch.at(neutrino_iter).push_back(max_shower_energy/ShowerLength);
	//     }


      const TVector3 ShowerStart     = shower->ShowerStart();
      const TVector3 ShowerDirection = shower->Direction();
      double ShowerOpenAngle         = shower->OpenAngle();

      
      float ShowerTrackLength = -999;
      float ShowerTracWidth   = -999; 
      
      //Get the shower track
      std::vector<art::Ptr<recob::Track> > showertrack = fmst.at(shower.key());
      //Check the track was sucessful.
      if(showertrack.size()>0){
	
	//Get the Length
	ShowerTrackLength = showertrack.at(0)->Length();
	std::cout << "ShowerTrackLength: " << ShowerTrackLength << std::endl;

	//Get the hits 
	std::vector<art::Ptr<recob::Hit> > showertrackhits = fmsth.at(showertrack.at(0).key());
	
	//Calculate the average spread from the shower direction
	float Perp = 0;
	for(auto const& showertrackhit: showertrackhits){
	  
	  //Get the spacepoint. 
	  std::vector<art::Ptr<recob::SpacePoint> > sps = fmsphsp.at(showertrackhit.key());
	  for(auto const& sp: sps){

	    //Calulate the perpendicular distance 
	    const Double32_t* sp_xyz = sp->XYZ();
	    TVector3 sp_position = {sp_xyz[0], sp_xyz[1], sp_xyz[2]};
	    TVector3 pos = sp_position - ShowerStart;
	    double  proj = pos.Dot(ShowerDirection);
	    pos = pos - proj * ShowerDirection;
	    Perp += pos.Mag(); 
	  }
	}
	ShowerTracWidth = Perp/(int)showertrackhits.size();
      }
      shower_tracklength_branch.at(neutrino_iter).push_back(ShowerTrackLength);
      shower_trackwidth_branch.at(neutrino_iter).push_back(ShowerTracWidth);


      
      //Get the hits
      std::vector<art::Ptr<recob::SpacePoint> > showerhits = fmsp.at(shower.key());

      //Workout the perpendicular length. Order hits based on the start position and direction
      OrderPerpendiuclarShowerHits(showerhits,ShowerStart,ShowerDirection);
      int length_iter = 0.9*showerhits.size();
      TVector3 EndPosition = SpacePointPosition(showerhits[length_iter]);
      TVector3 RelativeEndPos = EndPosition - ShowerStart;
      double ShowerPerpendicularLength = 2*(RelativeEndPos - (RelativeEndPos.Dot(ShowerDirection))*ShowerDirection).Mag();
      
      //Workout Perpendicular density
      double ShowerPerpendicularDensity = max_shower_energy/ShowerPerpendicularLength;

      //Workout 3D density.			
      double Shower3DDensity= max_shower_energy/(ShowerPerpendicularLength*ShowerPerpendicularLength*ShowerLength);

      //      std::cout << "ShowerPerpendicularLength: " << ShowerPerpendicularLength << " ShowerPerpendicularDensity: " << ShowerPerpendicularDensity << " Shower3DDensity: " << Shower3DDensity << std::endl;

      //Workout density gradients
      double showerperpendiculardensitygradient = ShowerPerpendicularDensityGradient(showerhits,ShowerStart,ShowerDirection,ShowerPerpendicularLength,fmsph);

      OrderShowerHits(showerhits,ShowerStart,ShowerDirection);
      //      std::cout << "Shower Energy: " << max_shower_energy << std::endl;
      double showerdensitygradient = ShowerDensityGradient(showerhits,ShowerStart,ShowerDirection,ShowerLength,fmsph);

      double pw = -999;
      double showerdensitygradient_new  = -999;
      showerdensitygradient_new = ShowerDensityGradient(showerhits,ShowerStart,ShowerDirection,ShowerLength,ShowerOpenAngle, fmsph, max_shower_energy*1.145,pw);
      //      std::cout << "ShowerPerpendicularDensityGradient: " << showerperpendiculardensitygradient << " ShowerDensityGradient: " << showerdensitygradient << std::endl;

      shower_length_perp_branch.at(neutrino_iter).push_back(ShowerPerpendicularLength);
      shower_density_perp_branch.at(neutrino_iter).push_back(ShowerPerpendicularDensity);
      shower_density_3D_branch.at(neutrino_iter).push_back(Shower3DDensity);
      shower_density_grad_perp_branch.at(neutrino_iter).push_back(showerperpendiculardensitygradient);
      shower_density_grad_branch.at(neutrino_iter).push_back(showerdensitygradient);
      shower_density_grad_new_branch.at(neutrino_iter).push_back(showerdensitygradient_new);
      shower_density_pw_new_branch.at(neutrino_iter).push_back(pw);
      shower_density_pwgrad_new_branch.at(neutrino_iter).push_back(pw/showerdensitygradient_new);

      shower_open_angle_branch.at(neutrino_iter).push_back(ShowerOpenAngle);

      shower_density_ratio_branch.at(neutrino_iter).push_back(ShowerLength/ShowerPerpendicularLength);
      shower_density_grad_ratio_branch.at(neutrino_iter).push_back(showerdensitygradient/showerperpendiculardensitygradient);

      shower_density_grad_perp_sq_branch.at(neutrino_iter).push_back(showerdensitygradient*showerdensitygradient);
      shower_density_grad_sq_branch.at(neutrino_iter).push_back(showerperpendiculardensitygradient*showerperpendiculardensitygradient);
      shower_density_grad_ratio_sq_branch.at(neutrino_iter).push_back(showerdensitygradient/showerperpendiculardensitygradient*showerdensitygradient/showerperpendiculardensitygradient);
      shower_hits_branch.at(neutrino_iter).push_back(showerhits.size());

    }

    //Add the number of showers to the true.
    number_of_showers_per_neutrino.at(neutrino_iter) = neutrino_showers.size();
    
    //Neutrino Pdg 
    nu_pdg_branch.at(neutrino_iter) = neutrino->PdgCode();

    //How well do we reconstruct the vertex. 

    //Define the vertex as being correct if within 5cm 
    std::vector<art::Ptr<recob::Vertex> > vertex = fmv.at(neutrino.key());

    if(vertex.size() > 1){
      throw cet::exception("RecoEfficencyFinder") << "we have too many recob vertex for pfparticles";
      return;
    }
  

    double vtx_xyz[3] = {-999,-999,-999};
    vertex[0]->XYZ(vtx_xyz);
     
    TVector3 vertex_position = {vtx_xyz[0],vtx_xyz[1],vtx_xyz[2]};

    //Ask if the vertex was in the FV
    if(containedInFV(vertex_position)){
      in_FV_branch.at(neutrino_iter) = 1;
    }
    else{
      in_FV_branch.at(neutrino_iter) = 0;
    }

    //Find the corresponding vertex. Hopefully there is just one event but pileup is ~few% 
    bool isReconstructed = false;
    
    if(mclist.size() < 1){
      throw cet::exception("RecoEfficencyFinder") << "why no truth :(";
      return;
    }

    art::Ptr<simb::MCTruth> mc_truth = mclist[0];
    int mc_truth_iter = 0;
    for(auto const& mc: mclist){
      ++mc_truth_iter;
      isReconstructed = isFromNuVertex(mc,vertex_position);
      if(isReconstructed){
	++num_v_recoed;
  	mc_truth = mc;
  	break;
      }
    }
    --mc_truth_iter;
    
    //Calculate the oscillation probability for the event
    int initnu = mcflux->at(mc_truth.key()).fntype;
    int finnu  = mc_truth->GetNeutrino().Nu().PdgCode();
    float nudistance =  mcflux->at(mc_truth_iter).fdk2gen + mcflux->at(mc_truth_iter).fgen2vtx;
    float loverE = nudistance/mc_truth->GetNeutrino().Nu().E();
    double osc_prob = SignalOscillationWeight(initnu,finnu,loverE);

    
    nu_osc_prob_branch.at(neutrino_iter) = osc_prob;
    nu_distance_branch.at(neutrino_iter) = nudistance;
    nu_interaction_type_branch.at(neutrino_iter) = mc_truth->GetNeutrino().InteractionType();
    nu_mode_branch.at(neutrino_iter)             = mc_truth->GetNeutrino().Mode();
    nu_E_branch.at(neutrino_iter)                = mc_truth->GetNeutrino().Nu().E();
    nu_X_branch.at(neutrino_iter)                = mc_truth->GetNeutrino().X();
    nu_W_branch.at(neutrino_iter)                = mc_truth->GetNeutrino().W();
    nu_Y_branch.at(neutrino_iter)                = mc_truth->GetNeutrino().Y();
    nu_QSqr_branch.at(neutrino_iter)             = mc_truth->GetNeutrino().QSqr();
    nu_Pt_branch.at(neutrino_iter)               = mc_truth->GetNeutrino().Pt();
    nu_Theta_branch.at(neutrino_iter)            = mc_truth->GetNeutrino().Theta();
    nu_truepdg_branch.at(neutrino_iter)          = mc_truth->GetNeutrino().Nu().PdgCode();
    nu_leptonE_branch.at(neutrino_iter)          = mc_truth->GetNeutrino().Lepton().E();
    nu_cc_branch.at(neutrino_iter)               = mc_truth->GetNeutrino().CCNC();
    nu_nuc_branch.at(neutrino_iter)              = mc_truth->GetNeutrino().HitNuc();

    //Get the true vertex KE
    float True_Vertex_Energy = 0;
    for(auto const& track: MCTrack_Energy_map){
      if(isPrimaryHadron(track.first,mc_truth,trueParticles,neutrino_iter,MCTrack_Energy_map)){
  	True_Vertex_Energy += track.second;
      }
    }
    vertex_trueKE_branch.at(neutrino_iter) = True_Vertex_Energy;
 
    if(isReconstructed){
      vertex_reco_branch.at(neutrino_iter) = 1;
    }

    //Loop over hadron daughter pfps and calculate the energy
    float Vertex_KE = 0;
    for(auto const& daughter: daughters){
      
      if(pfp_map[daughter]->PdgCode() == 11){continue;}

      art::Ptr<recob::PFParticle> daughter_pfp = pfp_map[daughter];

      //Get the track info 
      std::vector<art::Ptr<recob::Track> > daughter_track = fmt.at(daughter_pfp.key());
      if(daughter_track.size() == 0){continue;}
      if(daughter_track.size() != 1){
	throw cet::exception("RecoEfficencyFinder") << "we have too many recob tracks for pfparticles";
	return;
      }

      //Add the length 
      track_lengths_branch.at(neutrino_iter).push_back(daughter_track[0]->Length());
      
      //Get the the PID information 
      std::vector<art::Ptr<anab::ParticleID > > pids = fmpid.at(daughter_track[0].key());
      float PIDA = -999;
      if(pids.size() > 0){
	PIDA = pids.at(pids.size()-1)->PIDA();
      }
      track_PIDA_branch.at(neutrino_iter).push_back(PIDA);


      //Get the calorimetry info
      std::vector<art::Ptr<anab::Calorimetry> > daughter_calo = fmcal.at(daughter_track[0].key());
      if(daughter_calo.size() != 3){continue;}
      // if(daughter_calo.size() != 1){
      // 	throw cet::exception("RecoEfficencyFinder") << "we have too many calos for tracks" << daughter_calo.size() << std::endl;â‚¬;
      //   return;
      // }
      Vertex_KE += daughter_calo[2]->KineticEnergy(); 
    }
    vertex_recoKE_branch.at(neutrino_iter) = Vertex_KE;
  
    //Get the conversion gap 
    //    float min_coversion_gap = 999;
    int min_convgap_key = 0;
    //    int convgap_key = 0;
    for(auto const& neutrino_shower: neutrino_showers){

      //Get the conversion gap 
      TVector3 ShowerStart     = neutrino_shower->ShowerStart();//cm 
      double   conversion_gap  = (ShowerStart - vertex_position).Mag();
      shower_coversion_gap_branch.at(neutrino_iter).push_back(conversion_gap);
      
      //Get the closest shower to the vertex.
      //      if(conversion_gap < min_coversion_gap){
      //	min_convgap_key = convgap_key;
      //      }
      //  ++convgap_key;
    }

    

    //Calculate the residual of the closest shower
    int iter= 0;
    for(auto const& neutrino_shower: neutrino_showers){
      TVector3 ShowerStart     = neutrino_shower->ShowerStart();//cm 
      //      TVector3 conversion_vec  = (ShowerStart - vertex_position);
      
      //      TVector3 min_conversion_vec = (neutrino_showers[min_convgap_key]->ShowerStart() - vertex_position).Unit();
      TVector3 conversion_vec  = (ShowerStart - neutrino_showers[min_convgap_key]->ShowerStart());
      const TVector3 min_conversion_vec = neutrino_showers[min_convgap_key]->Direction();
      //      TVector3 othershower_dir =   (neutrino_shower->ShowerStart() - vertex_position).Unit(); 

      if(iter==0){
	conversion_vec = neutrino_shower->Direction();
      }
      ++iter;

      //      double perp = min_conversion_vec.Angle(othershower_dir);

      double len  = conversion_vec.Dot(min_conversion_vec);
      double perp = (conversion_vec - len*min_conversion_vec).Mag();
      shower_len_branch.at(neutrino_iter).push_back(len);
      shower_residual_dist_branch.at(neutrino_iter).push_back(perp);
    

      //if(iter !=0){
      std::cout << "Perp: " << perp << " Energy: " << neutrino_shower->Energy().at(neutrino_shower->best_plane()) << "Event: " << evt.event() << " Run: " <<  evt.run() << " Subrun: " << evt.subRun()  << std::endl;
      //}
    }
  
    //Get the total reco energy.
    float Nu_reco_Energy = 0;
    //    float max_s_energy = -999;
    for(auto const& pfp: pfp_map){
      art::Ptr<recob::PFParticle> parent   = pfp.second;
      art::Ptr<recob::PFParticle> temp_pfp = pfp.second;
      
      //Get the primary particle
      while(!parent->IsPrimary()){
  	temp_pfp = parent;
  	if(pfp_map.find(parent->Self()) == pfp_map.end()){parent = temp_pfp; break;}
  	parent = pfp_map[parent->Parent()];
      }

      //Check we come from the neutrino
      if(parent->Self() != neutrino->Self()){continue;}

      std::cout << "passed the neutrino self" << std::endl;

      //Get the energy from tracks
      if(pfp.second->PdgCode() == 13){

  	//Get the track info 
  	std::vector<art::Ptr<recob::Track> > track = fmt.at(pfp.second.key());
  	if(track.size() == 0){continue;}
  	if(track.size() != 1){
  	  throw cet::exception("RecoEfficencyFinder") << "we have too many recob tracks for pfparticles";
  	  return;
  	}

  	//Get the calorimetry info
  	std::vector<art::Ptr<anab::Calorimetry> > calo = fmcal.at(track[0].key());
	//  	if(calo.size() != 3){continue;}
	//  	if(calo.size() != 1){
  	//  throw cet::exception("RecoEfficencyFinder") << "we have too many calos for tracks";
  	//  return;
  	//}
	
	float TrackEnergy = -999;
	if(calo.size() > 0){
	  TrackEnergy = calo.at(calo.size()-1)->KineticEnergy();
	}
	if(TrackEnergy < 0){
	  float max_tack_energy = 0;
	  int trackit =0;
	  for(auto const& cal: calo){
	    if(cal->KineticEnergy() < 0){continue;}
	    max_tack_energy += cal->KineticEnergy();
	    ++trackit;
	  }
	  if(trackit == 0){
	    max_tack_energy = -999;
	  }
	  else{
	    max_tack_energy /= trackit;
	    TrackEnergy = max_tack_energy;
	  }
	}

	std::cout << "track energy: " << TrackEnergy << std::endl;
	std::cout<< "test0.1" << std::endl;
	if(TrackEnergy > 0){
	  Nu_reco_Energy += (TrackEnergy*1.1641);
	}      

	std::vector<art::Ptr<recob::Hit> > track_hits = fmth.at(track[0].key());


	//Get the true track id
	int truetrack_id = RecoUtils::TrueParticleIDFromTotalRecoHits(track_hits);

	if(MCTrack_Energy_map.find(truetrack_id) != MCTrack_Energy_map.end()){
	  track_trueE_branch.at(neutrino_iter).push_back(MCTrack_Energy_map[truetrack_id]);
	  track_resE_branch.at(neutrino_iter).push_back((MCTrack_Energy_map[truetrack_id]-TrackEnergy)/MCTrack_Energy_map[truetrack_id]);
	}
	else{
	  track_trueE_branch.at(neutrino_iter).push_back(-999);
	}

        if(trueParticles.find(truetrack_id) != trueParticles.end()){
	  track_pdg_branch.at(neutrino_iter).push_back(trueParticles[truetrack_id]->PdgCode());
	} 
	else{
	  track_pdg_branch.at(neutrino_iter).push_back(-999);
	}

	track_E_branch.at(neutrino_iter).push_back(TrackEnergy);

      }

      //is the daughter a shower.
      if(pfp.second->PdgCode() == 11){

  	//Do we have a corresponding shower particle.
  	std::vector<art::Ptr<recob::Shower> > shower = fmsh.at(pfp.second.key());
	
  	//Did we succeed at characterising the shower particle?
  	if(shower.size() == 0){continue;}
	
	
  	//If we have two then our charactisation did a silly.
  	if(shower.size() != 1){
  	  throw cet::exception("RecoEfficencyFinder") << "we have too many recob showers for pfparticles";
  	  return;
  	}

  	//Apply reconstruction energy cut. 
	const int ShowerBest_Plane = shower[0]->best_plane();
  	const std::vector<double> ShowerEnergyPlanes = shower[0]->Energy(); //MeV
	//  	auto const  max_shower_energy = *max_element(std::begin(ShowerEnergyPlanes), std::end(ShowerEnergyPlanes));
	float max_shower_energy = ShowerEnergyPlanes[0];
	std::cout << " shower energy 0: " << max_shower_energy << std::endl;
	if(ShowerBest_Plane != -999){
	  if((int) ShowerEnergyPlanes.size() > ShowerBest_Plane+1){
	    max_shower_energy = ShowerEnergyPlanes[ShowerBest_Plane];
	  }
	}
	std::cout << " shower energy 0: " << max_shower_energy << std::endl;
	if(max_shower_energy < 0){
	  std::cout << "undergoing less than" << std::endl;
	  max_shower_energy = 0; 
	  int showerit =0;
	  for(auto const& showerenergy: ShowerEnergyPlanes){
	    if(showerenergy < 0){continue;}
	    max_shower_energy += showerenergy;
	    ++showerit;
	  }
	  if(showerit == 0){
	    max_shower_energy = -999;
	  }
	  else{
	    max_shower_energy /= showerit;
	  }
	}
	     
  	// if(pfp.second->Parent() == neutrino->Self()){
  	//   if(max_shower_energy > max_s_energy){
  	//     max_s_energy = max_shower_energy;
  	//     //Then we have a shower
  	//   }
  	// }
  	// else{

	std::cout << "final shower e: " << max_shower_energy << std::endl;
	if(max_shower_energy > 0){
	  Nu_reco_Energy += (max_shower_energy*1.145);
	}
	  //}
      }
    }
    if(shower_energy_branch.at(neutrino_iter).size() > 0){
      if(Nu_reco_Energy < shower_energy_branch.at(neutrino_iter).at(0)){
	std::cout << "neutrino energy less than shower :/ Nu e:" << Nu_reco_Energy << " shower e: " << shower_energy_branch.at(neutrino_iter).at(0)  << std::endl;
      }
    }
    
    //    Nu_reco_Energy += max_s_energy;
    nu_reco_energy_branch.at(neutrino_iter) = Nu_reco_Energy;
    
    //Get the truth energy
    nu_truth_energy_branch.at(neutrino_iter) = mc_truth->GetNeutrino().Nu().E();
    ++neutrino_iter;
  
  }


  Tree->Fill();

  number_of_showers_per_neutrino.clear();
  shower_energy_branch.clear();
  truth_pid_branch.clear();
  true_energy_branch.clear();
  vertex_recoKE_branch.clear();
  vertex_trueKE_branch.clear();
  vertex_reco_branch.clear();
  track_lengths_branch.clear();
  shower_coversion_gap_branch.clear();
  shower_residual_dist_branch.clear();
  shower_length_perp_branch.clear();
  shower_density_perp_branch.clear();
  shower_density_3D_branch.clear();
  shower_density_grad_perp_branch.clear();
  shower_density_grad_branch.clear();
  shower_density_ratio_branch.clear();
  shower_density_grad_ratio_branch.clear();
  shower_len_branch.clear();
  shower_dEdx_branch.clear();
  shower_hits_branch.clear();
  nu_reco_energy_branch.clear();
  nu_truth_energy_branch.clear();
  nu_interaction_type_branch.clear();
  nu_mode_branch.clear();
  nu_E_branch.clear(); 
  nu_leptonE_branch.clear(); 
  nu_E_numtrue_branch.clear();
  nu_distance_branch.clear();
  track_E_branch.clear();
  track_PIDA_branch.clear();
  track_trueE_branch.clear();
  track_pdg_branch.clear();
  truetrackE_branch.clear();
  truepionE_branch.clear();
  trueprotonE_branch.clear();
  truekaonE_branch.clear();
  track_resE_branch.clear();
  shower_length_branch.clear();
  shower_tracklength_branch.clear();
  shower_trackwidth_branch.clear();
  shower_density_branch.clear();
  in_FV_branch.clear();
  shower_density_grad_perp_sq_branch.clear();
  shower_density_grad_sq_branch.clear();
  shower_density_grad_ratio_sq_branch.clear();
  nu_osc_prob_branch.clear();
  nu_pdg_branch.clear();
  shower_density_grad_new_branch.clear();
  shower_open_angle_branch.clear();
  shower_density_pw_new_branch.clear();
  shower_density_pwgrad_new_branch.clear();
  nu_X_branch.clear();
  nu_W_branch.clear();
  nu_Y_branch.clear();
  nu_QSqr_branch.clear();
  nu_Pt_branch.clear();
  nu_Theta_branch.clear();
  nu_truepdg_branch.clear();
  nu_cc_branch.clear();
  nu_nuc_branch.clear();
}

void ana::RecoEfficencyFinder::endJob(){



  int i=0;
  for(auto& segment: SegmentDensityPerpFinal){
    segment = segment/SegmentDensityPerpFinalN[i];
    SegmentDensityPerpGraph->SetPoint(SegmentDensityPerpGraph->GetN(),i,segment);
    ++i;
  }

  i=0;
  for(auto& segment: SegmentDensityFinal){
    
    if(SegmentDensityFinalN[i]==0){++i; continue;}

    double std_dev_x = 0;
    double std_dev_y = 0;
    if(SegmentDensityFinalN[i] != 0){
      std_dev_x = TMath::Sqrt((SegmentDensityFinalSq[i]/SegmentDensityFinalN[i]) - (segment*segment/(SegmentDensityFinalN[i]*SegmentDensityFinalN[i])));
      std_dev_y = TMath::Sqrt((LengthToSegmentFinalSq[i]/SegmentDensityFinalN[i]) - (LengthToSegmentFinal[i]*LengthToSegmentFinal[i]/(SegmentDensityFinalN[i]*SegmentDensityFinalN[i])));
      std_dev_x /= TMath::Sqrt(SegmentDensityFinalN[i]);
      std_dev_y /= TMath::Sqrt(SegmentDensityFinalN[i]);
			       
      segment =  segment/SegmentDensityFinalN[i];
    }
    else { 
      segment = 0;
    }

    double Length = LengthToSegmentFinal[i]/SegmentDensityFinalN[i]; 

    //    std::cout << " i: " << i << " segment: " << segment << " LengthToSegmentFinalSq[i]: " << Length << std::endl;
    //    std::cout << "error: " << "std_dev_x: " << std_dev_x << " std_dev_y: " << std_dev_y << std::endl; 
    SegmentDensityGraph->SetPoint(SegmentDensityGraph->GetN(),Length,segment);
    SegmentDensityGraph->SetPointError(SegmentDensityGraph->GetN()-1,std_dev_y,std_dev_x);
    ++i;
  }

  //  std::cout << "num_v_recoed: " << num_v_recoed << std::endl;
}

bool ana::RecoEfficencyFinder::isFromNuVertex(const art::Ptr<simb::MCTruth>& mc, const simb::MCParticle* &particle, float distance) const{

  if(!mc->NeutrinoSet()){return -999;}

  
  const TLorentzVector nuVtx     = mc->GetNeutrino().Nu().Trajectory().Position(0);
  const TLorentzVector partstart = particle->Position();
  return TMath::Abs((partstart - nuVtx).Mag()) < distance;
}

bool ana::RecoEfficencyFinder::isFromNuVertex(const art::Ptr<simb::MCTruth>& mc, TVector3& position, float distance) const{
  
  if(!mc->NeutrinoSet()){return -999;}

  const TVector3 nuVtx     = mc->GetNeutrino().Nu().Trajectory().Position(0).Vect();
  return TMath::Abs((position - nuVtx).Mag()) < distance;
}

//Check if the point is in the Active volume.
bool ana::RecoEfficencyFinder::containedInAV(const TVector3 &v) {
  for (auto const& AV: fActiveVolume) {
    if (AV.ContainsPosition(v)) return true;
  }
  return false;
}

//Check if the point is in the Active volume.
bool ana::RecoEfficencyFinder::containedInFV(const TVector3 &v) {
  for (auto const& FV: fFiducalVolume) {
    if (FV.ContainsPosition(v)) return true;
  }
  return false;
}


bool ana::RecoEfficencyFinder::isShowerContainedish(const std::vector<int>& shower, std::map<int,float>& Track_Energy_map, std::map<int, const simb::MCParticle*>& trueParticles){

  //Add up the energy of the shower
  float Energy = 0;
  for(auto const& shower_part: shower){
    Energy += trueParticles[shower_part]->E();
  }
  
  //Add up the deposited energy of the shower 
  float deposited_Energy = 0;
  for(auto const& shower_part: shower){
    deposited_Energy += Track_Energy_map[shower_part];
  }

  //If more than 90% of the shower has been identified on the collection plane it is contained.
  if(deposited_Energy/Energy > 0.9){return true;}
  
  return false;

}


bool ana::RecoEfficencyFinder::isPrimaryHadron(const int& track, art::Ptr<simb::MCTruth>& mc_truth, std::map<int,const simb::MCParticle*>& trueParticles,int neutrino_iter,std::map<int,float>& Track_Energy_map){

  if(trueParticles.find(track) == trueParticles.end()){return false;}

  //Check that it is from the vertex. 
  if(!isFromNuVertex(mc_truth,trueParticles[track])){
    return false;
  }

  truetrackE_branch.at(neutrino_iter).push_back(Track_Energy_map[track]);

  //Check if its a hadron 
  if(TMath::Abs(trueParticles[track]->PdgCode()) != 2212 &&
     TMath::Abs(trueParticles[track]->PdgCode()) != 211  &&
     TMath::Abs(trueParticles[track]->PdgCode()) != 321)
    {return false;}
  

  if(TMath::Abs(trueParticles[track]->PdgCode()) == 211){truepionE_branch.at(neutrino_iter).push_back(Track_Energy_map[track]);}
  if(TMath::Abs(trueParticles[track]->PdgCode()) == 2212){trueprotonE_branch.at(neutrino_iter).push_back(Track_Energy_map[track]);}
  if(TMath::Abs(trueParticles[track]->PdgCode()) == 321){truekaonE_branch.at(neutrino_iter).push_back(Track_Energy_map[track]);}

  return true;
}

//Orders hits from the distance away from the shower stem.
void ana::RecoEfficencyFinder::OrderPerpendiuclarShowerHits(std::vector<art::Ptr<recob::SpacePoint> >& sps, const TVector3& ShowerStartPosition, const TVector3& ShowerDirection){
  
  std::map<double,art::Ptr<recob::SpacePoint> > OrderedSpacePoints;

  //Loop over the spacepoints and get the pojected distance from the vertex.
  for(auto const& sp: sps){

    // Get the projection of the space point along the direction
    double len = SpacePointProjection(sp, ShowerStartPosition, ShowerDirection);

    //Get the length to the projection
    TVector3 perp = (SpacePointPosition(sp)-ShowerStartPosition) - len*ShowerDirection;
    double  len_perp = perp.Mag();
    

    //Add to the list
    OrderedSpacePoints[len_perp] = sp;
  }

  //Return an ordered list.
  sps.clear();
  for(auto const& sp: OrderedSpacePoints){
    sps.push_back(sp.second);
  }
  return;
}

void ana::RecoEfficencyFinder::OrderShowerHits(std::vector<art::Ptr<recob::SpacePoint> >& sps, const TVector3& ShowerStartPosition, const TVector3& ShowerDirection){
  
  std::map<double,art::Ptr<recob::SpacePoint> > OrderedSpacePoints;

  //Loop over the spacepoints and get the pojected distance from the vertex.
  for(auto const& sp: sps){

    // Get the projection of the space point along the direction
    double len = SpacePointProjection(sp, ShowerStartPosition, ShowerDirection);

    //Add to the list
    OrderedSpacePoints[len] = sp;
  }

  //Return an ordered list.
  sps.clear();
  for(auto const& sp: OrderedSpacePoints){
    sps.push_back(sp.second);
  }
  return;
}


double ana::RecoEfficencyFinder::ShowerPerpendicularDensityGradient(std::vector<art::Ptr<recob::SpacePoint> >& sps, const TVector3& ShowerStartPosition, const TVector3& ShowerDirection, double ShowerPerpendicularLength, art::FindManyP<recob::Hit> const& fmh){

  //  std::cout << "On perpendiular density" << std::endl;

  std::map<int, std::vector<art::Ptr<recob::SpacePoint> > > len_segment_map;
  double segmentsize = ShowerPerpendicularLength/fNSegments;

  //Split the the spacepoints into segments.
  for(auto const& sp: sps){
    
    //Get the position of the spacepoint
    TVector3 pos = SpacePointPosition(sp) - ShowerStartPosition;
    
    //Get the the projected length
    double len = pos.Dot(ShowerDirection);
    
    //Get the length to the projection
    TVector3 perp = pos - len*ShowerDirection ;
    double  len_perp = perp.Mag();
    
    //Get where the sp should be place.
    int sg_len = round(len_perp/segmentsize);

    len_segment_map[sg_len].push_back(sp);
  }

  double PreviousLength = -9999;

  //Loop over the segment and calculate the desnity
  float sumx=0;
  float sumy=0;
  float sumx2=0;
  float sumy2=0;
  float sumxy=0;
  float n=0;
  //Calculate the density gradent.
  for(auto& segment: len_segment_map){
    
    if(segment.second.size() < 5){continue;}

    //Reorder the Segements
    OrderShowerHits(segment.second,ShowerStartPosition,ShowerDirection);

    //Calculate the length 
    int length_iter         = 0.9*segment.second.size();
    TVector3 EndPosition    = SpacePointPosition(segment.second[length_iter]);
    TVector3 StartPosition  = SpacePointPosition(segment.second[0]); 

    double StartPoistionLength = (StartPosition - ShowerStartPosition).Dot(ShowerDirection);
    double EndPoisitionLength  = (EndPosition - ShowerStartPosition).Dot(ShowerDirection);

    double SegmentLength      = TMath::Abs(EndPoisitionLength-StartPoistionLength);

    if(SegmentLength == 0){continue;}

    //Force the length of the segment to be equal or larger than the last one
    if(SegmentLength < PreviousLength){SegmentLength = PreviousLength;}

    //Calculate the charge in the segement
    double SegmentCharge = TotalCharge(segment.second,fmh);

    double SegmentEnergy =  SegmentCharge*0.00153631;
    
    //Calculate the density 
    double SegmentDensity = -99999;

    if(segment.first == 0){
      SegmentDensity = (SegmentEnergy/(SegmentLength*segmentsize/2*segmentsize/2));
    }
    else{
      SegmentDensity = (SegmentEnergy/(SegmentLength*segmentsize*segmentsize));
    }

    //std::cout << "SegmentDensityPerpFinal.size(): " << SegmentDensityPerpFinal.size() << " segment.first: " << segment.first << std::endl;
    if(segment.first > -1 && segment.first < fNSegments){
      SegmentDensityPerpFinal.at(segment.first) += SegmentDensity;
      ++SegmentDensityPerpFinalN.at(segment.first);
    }


    double LengthToSegment = segment.first * segmentsize;

     //    std::cout << "Charge: " << SegmentCharge << " Length: " << SegmentLength << " Size: " << segmentsize << " numhits: " << segment.second.size() << " Density: " << SegmentDensity << std::endl;

    //Calculate the gradient using regression
    sumx  += LengthToSegment;
    sumy  += SegmentDensity;
    sumx2 += LengthToSegment * LengthToSegment;
    sumy2 += SegmentDensity*SegmentDensity;
    sumxy += LengthToSegment * SegmentDensity;
    ++n;
    
    PreviousLength = SegmentLength;
  }

  if((sumx2 - sumx*sumx) == 0){return 0;}
  
  double Densitygradient = (sumxy - sumx*sumy/n)/(sumx2 - sumx*sumx/n);
  return Densitygradient;
}

double ana::RecoEfficencyFinder::ShowerDensityGradient(std::vector<art::Ptr<recob::SpacePoint> >& sps, const TVector3& ShowerStartPosition, const TVector3& ShowerDirection, double ShowerLength, double& OpenAngle, art::FindManyP<recob::Hit> const& fmh, double ShowerEnergy, double& pw){

  std::map<int, std::vector<art::Ptr<recob::SpacePoint> > > len_segment_map;
  double segmentsize = ShowerLength/fNSegments;

  //Split the the spacepoints into segments.
  for(auto const& sp: sps){
    
    //Get the position of the spacepoint
    TVector3 pos = SpacePointPosition(sp) - ShowerStartPosition;
    
    //Get the the projected length
    double len = pos.Dot(ShowerDirection);
    
    //Get the length to the projection
    TVector3 perp = pos - (len*ShowerDirection);
    double perpLen = perp.Mag();

    //Get where the sp should be place.
    int sg_len = round(len/segmentsize);

    //    std::cout << "perpLen: " << perpLen << "TMath::Tan(0.5*OpenAngle)*len: " << TMath::Tan(0.5*OpenAngle)*len << "OpenAngle: " << OpenAngle << " len: " << len  << std::endl;

    //Only add if the hit within the cone
    if(perpLen > TMath::Abs(TMath::Tan(OpenAngle)*len)){
      //      std::cout << "removing hit in seg: " << std::endl;
      continue;
    }

    len_segment_map[sg_len].push_back(sp);
  }

  TGraph* graph = new TGraph();

  //Calculate the density gradent.
  for(auto& segment: len_segment_map){
    double sg_len = segment.first;
    
    //    std::cout << "sg_len: " << sg_len  << "len_segment_map[sg_len].size() : " <<segment.second.size() << std::endl;


    if(segment.second.size() < 10){continue;}

    //Calculate the charge in the segement
    double SegmentEnergy = TotalEnergy(segment.second,fmh);
    
    //Calculate the voume
    double lower_dist = sg_len*segmentsize - segmentsize/2;
    double upper_dist = sg_len*segmentsize + segmentsize/2;
    
    if(fRemoveStartFin){if(sg_len==0 || sg_len==fNSegments){continue;}}

    if(sg_len==0)         {lower_dist = 0;}
    if(sg_len==fNSegments){upper_dist = sg_len*segmentsize;}
    
    double littlevolume = lower_dist*TMath::Power((TMath::Tan(0.5*OpenAngle)*lower_dist),2)*TMath::Pi()/3;
    double bigvolume    = upper_dist*TMath::Power((TMath::Tan(0.5*OpenAngle)*upper_dist),2)*TMath::Pi()/3;
    double volume       = bigvolume - littlevolume;
    
    double SegmentDensity = SegmentEnergy/volume;

    double LengthToSegment = (lower_dist+upper_dist)/2;

    //    std::cout << "sg_len: " << sg_len << "Energy: " << SegmentEnergy << "volume: " << volume << " Length: " << LengthToSegment << "lower_dist: " << lower_dist << " upper_dist: " << upper_dist << " Size: " << segmentsize << " numhits: " << segment.second.size() << " Density: " << SegmentDensity << std::endl;

    if(segment.first > -1 && segment.first < fNSegments){
      SegmentDensityFinal.at(segment.first) += SegmentDensity/ShowerEnergy;
      SegmentDensityFinalSq.at(segment.first) += (SegmentDensity/ShowerEnergy)*(SegmentDensity/ShowerEnergy);

      ++SegmentDensityFinalN.at(segment.first);
      LengthToSegmentFinal.at(segment.first) += LengthToSegment;
      LengthToSegmentFinalSq.at(segment.first) += LengthToSegment*LengthToSegment;

      AllThePoints->SetPoint(AllThePoints->GetN(),LengthToSegment,SegmentDensity/ShowerEnergy);

    }


    
    graph->SetPoint(graph->GetN(),LengthToSegment,SegmentDensity/ShowerEnergy);
  }
  
  if(graph->GetN() < 3 ){return -999;}
  
  TF1 *fit = new TF1("fit", "[0]/x^[1]");
  fit->SetParLimits(1,1,2);
  fit->SetParLimits(0,0,1);

  graph->Fit(fit,"Q");
  
  double grad = fit->GetParameter(0);
  pw   = fit->GetParameter(1);
  

  delete fit;
  delete graph;
  //  std::cout << "test grad" << std::endl;
  //  std::cout << "grad: " << grad << std::endl;
  return grad;
}

double ana::RecoEfficencyFinder::ShowerDensityGradient(std::vector<art::Ptr<recob::SpacePoint> >& sps, const TVector3& ShowerStartPosition, const TVector3& ShowerDirection, double ShowerLength, art::FindManyP<recob::Hit> const& fmh){

  //  std::cout << "on gradient" << std::endl;

  std::map<int, std::vector<art::Ptr<recob::SpacePoint> > > len_segment_map;
  double segmentsize = ShowerLength/fNSegments;

  //Split the the spacepoints into segments.
  for(auto const& sp: sps){
    
    //Get the position of the spacepoint
    TVector3 pos = SpacePointPosition(sp) - ShowerStartPosition;
    
    //Get the the projected length
    double len = pos.Dot(ShowerDirection);
    
    //Get the length to the projection
    TVector3 perp = pos - len*ShowerDirection;
    
    //Get where the sp should be place.
    int sg_len = round(len/segmentsize);
    len_segment_map[sg_len].push_back(sp);
  }

  double PreviousSegmentPendicularLength = -99999;

  //Loop over the segment and calculate the desnity
  // float sumx=0;
  // float sumy=0;
  // float sumx2=0;
  // float sumy2=0;
  // float sumxy=0;
  // float n=0;

  TGraph* graph = new TGraph();

  //Calculate the density gradent.
  for(auto& segment: len_segment_map){

    //Reorder the Segements
    OrderPerpendiuclarShowerHits(segment.second,ShowerStartPosition,ShowerDirection);

    if(segment.second.size() < 5){continue;}

    //Calculate the length 
    int length_iter = 0.9*segment.second.size();
    TVector3 EndPosition    = SpacePointPosition(segment.second[length_iter]);
    double len = (ShowerStartPosition - EndPosition).Dot(ShowerDirection);

    //Get the length to the projection                                                            
    TVector3 perp = (ShowerStartPosition - EndPosition) - len*ShowerDirection;
    double  SegmentPendicularLength = 2*perp.Mag();

    if(SegmentPendicularLength == 0){continue;}

    if(SegmentPendicularLength < PreviousSegmentPendicularLength){SegmentPendicularLength = PreviousSegmentPendicularLength;} 

    //Calculate the charge in the segement
    double SegmentCharge = TotalCharge(segment.second,fmh);

    //Calculate the Energy.
    double SegmentEnergy =  SegmentCharge*0.00153631;

    //Calculate the density 
    double SegmentDensity = -99999;

    if(segment.first == 0){
      SegmentDensity = (SegmentEnergy/(SegmentPendicularLength*SegmentPendicularLength*segmentsize/2));
    }
    else{
      SegmentDensity = (SegmentEnergy/(SegmentPendicularLength*SegmentPendicularLength*segmentsize));
    }

    //std::cout << "SegmentDensityFinal.size(): " << SegmentDensityFinal.size() << " segment.first: " << segment.first << std::endl;
    // if(segment.first > -1 && segment.first < fNSegments){
    //   SegmentDensityFinal.at(segment.first) += SegmentDensity;
    //   ++SegmentDensityFinalN.at(segment.first);
    // }

    double LengthToSegment = segment.first * segmentsize;

    //    std::cout << "Charge: " << SegmentCharge << " LengthToSegment: " << LengthToSegment << " Perp Length: " << SegmentPendicularLength << " segment.first: " << segment.first << " Size: " << segmentsize << " numhits: " << segment.second.size() << " SegmentDensity: " << SegmentDensity <<  std::endl;

    graph->SetPoint(graph->GetN(),LengthToSegment,SegmentDensity);

    //Calculate the gradient using regression
    // sumx  += LengthToSegment;
    // sumy  += SegmentDensity;
    // sumx2 += LengthToSegment  * LengthToSegment;
    // sumy2 += SegmentDensity * SegmentDensity;
    // sumxy += SegmentDensity * LengthToSegment;
    // ++n;
    // std::cout << "sumxy: " << sumxy << " sumx*sumy: " << sumx*sumy << "  (sumxy - sumx*sumy): " <<  (sumxy - sumx*sumy) << std::endl;
    // std::cout << "sumx2: " << sumx2 << " sumx*sumx: " << sumx*sumx << " (sumx2 - sumx*sumx): " << (sumx2 - sumx*sumx) << std::endl; 

    PreviousSegmentPendicularLength = SegmentPendicularLength;
  }

  if(graph->GetN() == 0){return 0;}

  TF1 *fit = new TF1("fit", "[0] + [1]/x^2");
  graph->Fit(fit,"Q");
  double grad =  fit->GetParameter(1);
  delete fit;
  delete graph;

  //  std::cout << "grad: " << grad << std::endl;
  ++Nfinal;
  return grad;

  // if((sumx2 - sumx*sumx) == 0){return 0;}

  // ++Nfinal;
  
  // double Densitygradient = (sumxy - sumx*sumy/n)/(sumx2 - sumx*sumx/n);
  // return Densitygradient;

}


double ana::RecoEfficencyFinder::TotalEnergy(const std::vector<art::Ptr<recob::SpacePoint> >&sps, art::FindManyP<recob::Hit> const& fmh){
  
  std::map<int,double> TotalCharge_plane;
  std::map<int,int> TotalCharge_int;
  for(auto const& sp: sps){
    double Charge =  SpacePointCharge(sp,fmh);
    double Time   =  SpacePointTime(sp,fmh);
    int    Plane  =  SpacePointPlane(sp,fmh);
    Charge *= TMath::Exp((fDetProp->SamplingRate() * Time ) / (fDetProp->ElectronLifetime()*1e3));
    TotalCharge_plane[Plane] += Charge;
    ++TotalCharge_int[Plane];
  }

  int max_plane = -999;
  for(auto const& plane: TotalCharge_int){
    if(plane.second > max_plane){
      max_plane = plane.first;
    }
  }
  if(max_plane == -999){return 0;}
    
  double TotalEnergy = TotalCharge_plane[max_plane]*fConversion[max_plane];

  return TotalEnergy; 
}

double ana::RecoEfficencyFinder::TotalCharge(const std::vector<art::Ptr<recob::SpacePoint> >&sps, art::FindManyP<recob::Hit> const& fmh){
  
  double TotalCharge = 0;

  for(auto const& sp: sps){
    double Charge =  SpacePointCharge(sp,fmh);
    double Time   =  SpacePointTime(sp,fmh);
    Charge *= TMath::Exp((fDetProp->SamplingRate() * Time ) / (fDetProp->ElectronLifetime()*1e3));
    TotalCharge += Charge;
  }
  return TotalCharge; 
}


int ana::RecoEfficencyFinder::SpacePointPlane(art::Ptr<recob::SpacePoint> const& sp,
						  art::FindManyP<recob::Hit> const& fmh) const {

  std::vector<art::Ptr<recob::Hit> > hits = fmh.at(sp.key());

  if(hits.size() != 1){
    throw cet::exception("RecoEfficencyFinder") << "Spacepoint is not matched to 1 hit. This was unexpected";
  }

  return hits[0]->WireID().Plane;

}

double ana::RecoEfficencyFinder::SpacePointCharge(art::Ptr<recob::SpacePoint> const& sp,
						  art::FindManyP<recob::Hit> const& fmh) const {
  
  double Charge = 0;
  
  //Average over the charge even though there is only one
  std::vector<art::Ptr<recob::Hit> > hits = fmh.at(sp.key());
  for(auto const& hit: hits){
    Charge += hit->Integral();
  }
  
  Charge /= (float) hits.size();
  
  return Charge;
}

//Return the spacepoint time.
double ana::RecoEfficencyFinder::SpacePointTime(art::Ptr<recob::SpacePoint> const& sp,
						art::FindManyP<recob::Hit> const& fmh) const {
  
  double Time = 0;

  //Avergae over the hits
  std::vector<art::Ptr<recob::Hit> > hits = fmh.at(sp.key());
  for(auto const& hit: hits){
    Time += hit->PeakTime();
  }

  Time /= (float) hits.size();
  return Time;
}


double ana::RecoEfficencyFinder::SpacePointProjection(const art::Ptr<recob::SpacePoint>&sp,
					      TVector3 const& vertex, 
					      TVector3 const& direction) const {

  // Get the position of the spacepoint
  TVector3 pos = SpacePointPosition(sp) - vertex;

  // Get the the projected length
  double projLen = pos.Dot(direction);

  return projLen;
}

TVector3 ana::RecoEfficencyFinder::SpacePointPosition(art::Ptr<recob::SpacePoint> const& sp) const {

  const Double32_t* sp_xyz = sp->XYZ();
  TVector3 sp_postiion = {sp_xyz[0], sp_xyz[1], sp_xyz[2]};
  return sp_postiion;
}

//Assumes dm_21=dm_12=dm_13...=0 
double ana::RecoEfficencyFinder::SignalOscillationWeight(int& initpdg, int& finpdg, float& lOverE) const {

  //Madness We do not oscillate intrinsic nues :O 
  if(TMath::Abs(initpdg) == 12){
    if(initpdg == finpdg){ 
      return 1;
    }
    return 0;
  }

  //Calculate the OscProbability 
  double sindm = std::sin(fOscDimensFactor * lOverE/1000 * fdmsq);
  double sinsqdm = sindm * sindm;
  
  double OscProb = 1; 

  if(TMath::Abs(initpdg) == 14){
    if(TMath::Abs(finpdg) == 14){
      OscProb = 1-fsinsq2thmumu * sinsqdm;
    }
    else{
      OscProb = fsinsq2thmue * sinsqdm;
    }
  }
  return OscProb;
}


DEFINE_ART_MODULE(ana::RecoEfficencyFinder)
